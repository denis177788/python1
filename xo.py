#  ВНИМАНИЕ !!!

# данная программа использует движок
# который просчитывает все возможные ходы

# Вы не сможете её обыграть!

d = '.........'

# поскольку количество просчитываемых движком ходов составляет несколько тысяч,
# в целях ускорения работы программы я не использую списки, словари и прочий "сахар".
# (изначально я пробовал использовать список с вложенным списком для хранения текущего позиции,
# но после отказа от этой идеи скорость работы программы существенно возросла!)
# текущая игровая позиция хранится в переменной d,
# которая представляет из себя строку из 9 символов (по количеству полей),
# где "x" будет означать крестик, "o" - нолик, а "." - пустое поле




import random



# функция отрисовки игрового поля:

def print_desk(d):
    print('   1  2  3')
    for a in range(3):
        s = abc[a]
        for b in range(3):
            sym = d[a*3 + b]
            if sym == 'o':
                sym = '◯'  # красивое лучше, чем некрасивое:)
            s = s + '  ' + sym
        print(s)


# функция is_win проверяет, есть ли на поле победа
# она возвращает 1 если победили крестики, -1 если победили нолики, и 0 если пока нет победы

# поскольку движок просчитывает все возможные ходы,
# данная функция будет запускаться тысячи раз.
# и поэтому я не стал использовать конструкции, которые могут увеличить время работы функции (например циклы).
# встренные питоновские функции также могут использовать циклы внутри себя, поэтому их я тоже не стал использвать.
# весь алгоритм построен на ифах

xxx = 'xxx'  # константы задаю вне тела функции, чтобы значение не присваивалось каждый раз при запуске функции
ooo = 'ooo'  # (это нужно для ускорения работы)
def is_win(d):
    if d[0:3]==xxx or d[3:6]==xxx or d[6:9]==xxx or d[0::3]==xxx or d[1::3]==xxx or d[2::3]==xxx \
            or d[0]+d[4]+d[8]==xxx or d[2]+d[4]+d[6]==xxx:
        return 1
    if d[0:3]==ooo or d[3:6]==ooo or d[6:9]==ooo or d[0::3]==ooo or d[1::3]==ooo or d[2::3]==ooo \
            or d[0]+d[4]+d[8]==ooo or d[2]+d[4]+d[6]==ooo:
        return -1
    return 0


# get_xo - вспомогательная функция
# которая возвращает "x", если i = 1
# и возвращает "o" если i не равно 1 (в программе это может быть только -1)
def get_xo(i):
    return 'x' if i == 1 else 'o'



# функция engine - это движок.
# он умеет запускать сам себя по многу раз - перебирает все возможные ходы
# на входе передаём d (текущая игровая ситуация), who_step - чей ход
# если ref_e = False взвращает ход в формате например "a1" (это значит, что функция запущена из основного модуля)
# если ref_e = True - возвращает оценку текущей ситуации от 0 до 1 (это значит, что функция запустила сама себя)

abc = 'abc'   # просто константа

def engine(d, who_step, ret_e=False):
    best_e = None
    best_step = None
    for a in range(3):
        for b in range (3):
            if d[a*3+b] == '.':  # ищем свободное поле
                d1 = d[0:a*3+b] + get_xo(who_step) + d[a*3+b+1:] # подставляем возможный ход
                e = is_win(d1) * who_step  # смотрим, есть ли победа
                if -0.5 < e < 0.5:  # если победы нет
                    e1 = engine(d1, who_step * -1, True)   # то запускаем движок снова
                    if e1 != None:  # если пришла ошибка, то закончились ходы
                        e = e - e1 / 2   # если ошибки нет, то записываем результат, но с каждым последующим ходм / 2
                # сравниваем результаты с лучшим
                if (best_e == None) or (e > best_e):
                    best_e = e
                    best_step = abc[a]+str(b+1)
                elif (e == best_e) and (ret_e == False) and (random.choice([True, False])):
                    best_step = abc[a]+str(b+1)   # если результаты одинаковые, тогда ход выбирается рандомно
    return best_e if ret_e else best_step


# следующая функция запрашивает ход от пользователя,
# проверяет ошибки и возвращает ход в формате буква+цифра (например, "a1")

def input_step(d):
    s = input('Ваш ход:')
    # проверяем возможные ошибки
    if len(s) != 2:
        return ''
    if abc.find(s[0]) == -1:
        return ''
    if not (s[1] == '1' or s[1] == '2' or s[1] == '3'):
        return ''
    # проверяем поле на занятость
    if d[abc.find(s[0])*3 + int(s[1])-1] != '.':
        return ''
    return s


# следующая функция записывает новый ход в строку d
# (фактически она возвращает новую строку с записынным в ней новым ходом)

def new_step(d, step, who_step):
    pos = abc.find(step[0])*3 + int(step[1])-1
    d1 = d[0:pos] + get_xo(who_step) + d[pos + 1:]
    return d1


# основная часть



# кто крестик
if random.choice([True, False]):
    comp_is = 1  # ПК крестик
else:
    comp_is = -1  # ПК нолик

count = 0   # счётчик ходов

# первый ход
if comp_is == 1:
    if random.choice([True, False]):
        d = new_step(d, 'b2', 1)   # в 50% случаев ходим в центр
    else:
        d = new_step(d, abc[random.randint(0, 2)] + str(random.randint(0, 2)+1), 1)
    count += 1

while True:
    print_desk(d)   # печатаем доску
    # ---- ход игрока ----
    index = input_step(d)    # запрашиваем ход у игрока
    if index == '':   # если ошибка то выход
        print('Ошибка!')
        break
    d = new_step(d, index, comp_is * -1)   # записываем ход
    count += 1  # счётчик ходов
    e = is_win(d)      # проверка на выигрыш
    if e == 1 or e == -1:
        print_desk(d)  # выводим последний ход на экран
        print('Вы выиграли!')
        break
    if count == 9:    # проверка на ничью
        print_desk(d)  # выводим последний ход на экран
        print('Ничья!')
        break
    # ---- ход компьютера ----
    index = engine(d, comp_is)    # запускаем движок
    print ('Компьютер сходил', index)
    d = new_step(d, index, comp_is)   # записываем ход
    count += 1   # счётчик ходов
    e = is_win(d)    # проверка на выигрыш
    if e == 1 or e == -1:
        print_desk(d)  # выводим последний ход на экран
        print('Вы проиграли!')
        break
    if count == 9:  # проверка на ничью
        print_desk(d)  # выводим последний ход на экран
        print('Ничья!')
        break




